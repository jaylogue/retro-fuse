/*
 * Copyright 2021 Jay Logue
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file  POSIX-compliant cksum command for Unix v6
 */

extern int ldivr;

int crc[2];
int len[2];
char iobuf[512];
char ulcbuf[12];

main(argc,argv)
char **argv;
{
    int i, f;
    register char *p;
    register int c;

    i = 1;
    do {
        if (argc <= 1)
            f = 0;
        else if (argv[i][0] == '-' && argv[i][1] == 0)
            f = 0;
        else if ((f = open(argv[i], 0)) < 0) {
            logerr(argv[0], argv[i]);
            continue;
        }
        crcinit();
        len[0] = len[1] = 0;
        for (;;) {
            c = read(f, iobuf, 512);
            if (c <= 0)
                break;
            p = iobuf;
            while (c > 0) {
                crcadd(*p);
                len[0]++;
                if (len[0] == 0)
                    len[1]++;
                p++;
                c--;
            }
        }
        if (c < 0)
            logerr(argv[0], argv[i]);
        else {
            /* hash the length of the file, in little-endian format,
               with high-order zero bytes suppressed. */
            if (len[1] != 0 || len[0] != 0) {
                c = len[0] & 255;
                crcadd(c);
                c = (len[0] >> 8) & 255;
                if (len[1] != 0 || c != 0)
                    crcadd(c);
                if (len[1] != 0) {
                    c = len[1] & 255;
                    crcadd(c);
                    c = (len[1] >> 8) & 255;
                    if (c != 0)
                        crcadd(c);
                }
            }
            crcfinal();
            printf("%s ", ulocv(crc[1], crc[0]));
            printf("%s", ulocv(len[1], len[0]));
            if (argc > 1)
                printf(" %s", argv[i]);
            printf("\n");
        }
        if (f != 0)
            close(f);
    } while (++i < argc);
}

/* 
 * POSIX chsum uses the ITU I.363.5 crc32 algorithm (a.k.a crc32a, a.k.a. CRC-32/BZIP2)
 * but with an initial value of 0, rather than -1.
 *
 * Algorithm parameters:
 *     Polynomial: 0x04C11DB7
 *     Initial value: 0
 *     CRC Shift: Left
 *     Reverse input data: No
 *     Reverse CRC: No
 *     Final XOR: 0xFFFFFFFF
 */

int crctab[512] {
         0,      0,   7607,   1217,  15214,   2434,   9945,   3395,
     30428,   4868,  27499,   6085,  19890,   6790,  20485,   7751,
     -4680,   9736,  -4081,   8905, -10538,  12170, -13471,  11083,
    -25756,  13580, -31021,  12749, -24566,  15502, -16963,  14415,
     -9360,  19473, -14649,  18640,  -8162,  17811,   -599,  16722,
    -21076,  24341, -20453,  23508, -26942,  22167, -29835,  21078,
     14024,  27161,  11135,  28376,   3494,  25499,   4113,  26458,
     16404,  31005,  23971,  32220,  31610,  28831,  26317,  29790,
    -18720, -26589, -21673, -25374, -29298, -28255, -28615, -27296,
    -16324, -29913,  -8821, -28698,  -1198, -32091,  -6427, -31132,
     23384, -16853,  18159, -17686,  24630, -18519,  32129, -19608,
     11652, -21201,  12339, -22034,   5866, -23379,   2909, -24468,
     28048, -11214,  28711, -12045,  22270,  -8784,  19273,  -9871,
      6988, -14538,   1787, -15369,   8226, -12620,  15765, -13707,
    -32728,  -3526, -25185,  -2309, -17594,  -1096, -22799,   -135,
     -2316,  -7874,  -5309,  -6657, -12902,  -5956, -12243,  -4995,
     28791,  13446,  28096,  12359,  19225,  15620,  22190,  14789,
      1707,  10114,   6940,   9027,  15813,  11776,   8306,  10945,
    -25137,   4750, -32648,   5711, -22879,   6924, -17642,   8141,
     -5357,    394,  -2396,   1355, -12163,   2056, -12854,   3273,
    -21753,  30871, -18768,  31830, -28567,  28949, -29218,  30164,
     -8741,  27539, -16276,  28498,  -6475,  25105,  -1278,  26320,
     18111,  24223,  23304,  23134,  32209,  22301,  24678,  21468,
     12387,  19867,  11732,  18778,   2829,  17433,   5818,  16600,
    -14697, -21339,  -9440, -22428,   -519, -23257,  -8114, -24090,
    -20405, -16479, -20996, -17568, -29915, -18909, -26990, -19742,
     11055, -30035,  13976, -29076,   4161, -31953,   3574, -30738,
     24051, -26199,  16452, -25240,  26269, -28629,  31530, -27414,
      7655,  -8012,     80,  -7051,   9865,  -5834,  15166,  -4617,
     27451,  -3152,  30348,  -2191,  20565,  -1486,  19938,   -269,
     -4001, -14660,  -4632, -15747, -13519, -12482, -10618, -13313,
    -31101, -10824, -25804, -11911, -16915,  -9158, -24486,  -9989,
     -7954,  26892,   -679,  28109,  -9344,  24718, -14793,  25679,
    -27086,  31240, -29819,  32457, -21156,  29578, -20245,  30539,
      3414,  20228,   4321,  19397,  13880,  18054,  11151,  16967,
     31626,  23552,  26173,  22721,  16612,  21890,  23891,  20803,
     15262,   9501,   9769,   8668,    240,  11423,   7495,  10334,
     19778,  13849,  20725,  13016,  30252,  16283,  27547,  15194,
    -10714,    789, -13423,   2004,  -4792,   2711,  -3841,   3670,
    -24326,   4113, -17075,   5328, -25708,   6547, -31197,   7506,
     22030,  -3793,  19385,  -2578,  28000,  -1875,  28887,   -916,
      8402,  -7637,  15717,  -6422,   7100,  -5207,   1547,  -4248,
    -17482, -10457, -23039, -11290, -32552,  -8539, -25233,  -9628,
    -12950, -15325, -12067, -16158,  -2556, -12895,  -5197, -13984,
    -29314, -17090, -28471, -17921, -18928, -19268, -21593, -20355,
     -1118, -20934,  -6635, -21765, -16180, -22600,  -8837, -23687,
     24774, -25802,  32113, -24585,  23464, -27980,  17951, -27019,
      5658, -30670,   2989, -29453,  11636, -32336,  12483, -31375,
    -28519,  23946, -29394,  22859, -21513,  21512, -18880,  20681,
     -6587,  20110,  -1038,  19023,  -8917,  18188, -16228,  17357,
     32033,  31618,  24726,  32579,  17999,  29184,  23544,  30401,
      3069,  26758,   5706,  27719,  12435,  24836,  11556,  26053,
     19433,   4507,  22110,   5466,  28807,   6169,  27952,   7384,
     15669,    671,   8322,   1630,   1627,   2845,   7148,   4060,
    -22959,  14227, -17434,  13138, -25281,  15889, -32632,  15056,
    -12147,   9367, -12998,   8278,  -5149,  11541,  -2476,  10708,
      9849, -14935,  15310, -16024,   7447, -13269,    160, -14102,
     20645, -10579,  19730, -11668,  27595,  -8401,  30332,  -9234,
    -13375,  -7263, -10634,  -6304,  -3921,  -5597,  -4840,  -4382,
    -17123,  -3931, -24406,  -2972, -31117,  -1753, -25660,   -538,
      -759, -30280,  -8002, -29319, -14745, -32710,  -9264, -31493,
    -29739, -25924, -27038, -24963, -20293, -27842, -21236, -26625,
      4273, -20560,   3334, -21647,  11231, -22990,  13928, -23821,
     26221, -17228,  31706, -18315,  23811, -19146,  16564, -19977,
};

crcinit()
{
    /* crc = 0 */
    crc[0] = 0;
    crc[1] = 0;
}

crcadd(b)
int b;
{
    int i;

    /* i = ((crc >> 24) ^ b) & 0xFF */
    i = ((crc[1] >> 8) ^ b) & 255;

    /* crc = (crc << 8) ^ crctab[i] */
    crc[1] = (crc[1] << 8) | ((crc[0] >> 8) & 255);
    crc[0] = crc[0] << 8;
    i = i * 2;
    crc[0] = crc[0] ^ crctab[i];
    crc[1] = crc[1] ^ crctab[i+1];
}

crcfinal()
{
    /* crc = crc ^ 0xFFFFFFFF */
    crc[1] = crc[1] ^ 65535;
    crc[0] = crc[0] ^ 65535;
}

ulocv(hi, low)
int hi, low;
{
    register char * p;

    p = &ulcbuf[12];
    *--p = 0;
    do {
        *--p = divu32(&hi, &low, 10) + '0';
    } while (hi != 0 || low != 0);
    return p;
}

divu32(hi, low, divisor)
char *hi, *low;
int divisor;
{
    hi[1]  = ldiv(0,                ( hi[1] & 255), divisor);
    hi[0]  = ldiv(0, (ldivr << 8) | ( hi[0] & 255), divisor);
    low[1] = ldiv(0, (ldivr << 8) | (low[1] & 255), divisor);
    low[0] = ldiv(0, (ldivr << 8) | (low[0] & 255), divisor);
    return ldivr;
}

logerr(s, fn)
char *s, *fn;
{
    if (fn) {
        while (*s)
            write(2, s++, 1);
        write(2, ": ", 2);
        s = fn;
    }
    perror(s);
}
